const version = "v5:",
	fallback_avatar = "/i/fallbacks/avatar.svg",
	fallback_image = "/i/fallbacks/image.svg",
	offline_image = "/i/fallbacks/offline.svg",
	offline_page = "/offline/",
	preinstall = [
		"/favicon.png",
		fallback_avatar,
		fallback_image,
		offline_image,
		"/c/default.min.css",
		"/c/advanced.min.css",
		"/j/main.min.js",
		offline_page,
	],
	sw_caches = {
		static: { name: "v5:static" },
		images: { name: "v5:images", limit: 75 },
		pages: { name: "v5:pages", limit: 5 },
		posts: { name: "v5:posts", limit: 10, path: /\/notebook\/.+/ },
		other: { name: "v5:other", limit: 50 },
	},
	ignore = [
		"www.google-analytics.com/r/collect",
		".ogg",
		".mp3",
		".mp4",
		".ogv",
		".webm",
		"chrome-extension",
	],
	high_priority = [/aaron\-gustafson\.com/, /adaptivewebdesign\.info/],
	avatars = /webmention\.io/,
	fetch_config = { images: { mode: "no-cors" } };
let save_data,
	slow_connection = !1;
function trimCache(e, t) {
	caches.open(e).then((a) => {
		a.keys().then((n) => {
			n.length > t && a.delete(n[0]).then(trimCache(e, t));
		});
	});
}
function saveToCache(e, t, a) {
	caches.open(e).then((e) => e.put(t, a));
}
function refreshCachedCopy(e, t) {
	fetch(e)
		.then((a) => {
			caches.open(t).then((t) => t.put(e, a));
		})
		.catch(respondWithOfflinePage);
}
function shouldBeIgnored(e) {
	let t = ignore.length;
	for (; t--; ) if (e.indexOf(ignore[t]) > -1) return !0;
	return !1;
}
function isHighPriority(e) {
	let t = high_priority.length;
	for (; t--; ) if (high_priority[t].test(e)) return !0;
	return !1;
}
function respondWithOfflinePage() {
	return caches.match(offline_page).catch(respondWithServerOffline);
}
function respondWithFallbackImage(e, t = fallback_image) {
	const a = avatars.test(e) ? fallback_avatar : t;
	return caches.match(a).catch(respondWithServerOffline);
}
function respondWithOfflineImage() {
	return caches.match(offline_image);
}
function respondWithServerOffline() {
	return new Response("", {
		status: 408,
		statusText: "The server appears to be offline.",
	});
}
function requestIsLikelyForHTML(e) {
	const t = e.split("/").pop();
	return !("" != t && !/.+\.html$/.test(t) && /\..+$/.test(t));
}
("connection" in navigator &&
	((slow_connection = navigator.connection.downlink < 0.5),
	(save_data = navigator.connection.saveData)),
	self.addEventListener("activate", (e) => {
		e.waitUntil(
			caches
				.keys()
				.then((e) =>
					Promise.all(
						e.filter((e) => !e.startsWith("v5:")).map((e) => caches.delete(e)),
					),
				),
		);
	}),
	addEventListener("message", (e) => {
		if ("clean up" == e.data)
			for (let e in sw_caches)
				void 0 != sw_caches[e].limit &&
					trimCache(sw_caches[e].name, sw_caches[e].limit);
	}),
	self.addEventListener("fetch", (e) => {
		const t = e.request,
			a = t.url;
		"GET" !== t.method ||
			shouldBeIgnored(a) ||
			(void 0 == save_data && (save_data = t.headers.get("save-data")),
			/\.json$/.test(a) || /jsonp\=/.test(a)
				? e.respondWith(
						caches.match(t).then((a) =>
							a
								? (save_data ||
										slow_connection ||
										e.waitUntil(refreshCachedCopy(t, sw_caches.other.name)),
									a)
								: fetch(t)
										.then((a) => {
											const n = a.clone();
											return (
												e.waitUntil(saveToCache(sw_caches.other.name, t, n)),
												a
											);
										})
										.catch(respondWithServerOffline),
						),
					)
				: /\.js$/.test(a) && isHighPriority(a)
					? e.respondWith(
							caches.match(t).then((a) =>
								a
									? (save_data ||
											slow_connection ||
											e.waitUntil(refreshCachedCopy(t, sw_caches.static.name)),
										a)
									: fetch(t)
											.then((a) => {
												const n = a.clone();
												return (
													e.waitUntil(saveToCache(sw_caches.static.name, t, n)),
													a
												);
											})
											.catch(respondWithServerOffline),
							),
						)
					: t.headers.get("Accept").includes("text/html") ||
						  requestIsLikelyForHTML(a)
						? sw_caches.posts.path.test(a)
							? e.respondWith(
									caches
										.match(t)
										.then((a) =>
											a
												? (save_data ||
														slow_connection ||
														e.waitUntil(
															refreshCachedCopy(t, sw_caches.posts.name),
														),
													a)
												: fetch(t).catch(respondWithOfflinePage),
										),
								)
							: e.respondWith(
									caches.match(t).then((a) =>
										a
											? (save_data ||
													slow_connection ||
													e.waitUntil(
														refreshCachedCopy(t, sw_caches.pages.name),
													),
												a)
											: fetch(t)
													.then((a) => {
														const n = a.clone();
														return (
															e.waitUntil(
																saveToCache(sw_caches.pages.name, t, n),
															),
															a
														);
													})
													.catch(respondWithOfflinePage),
									),
								)
						: t.headers.get("Accept").includes("image")
							? e.respondWith(
									caches.match(t).then(
										(n) =>
											n ||
											(isHighPriority(a)
												? fetch(t, fetch_config.images)
														.then((a) => {
															const n = a.clone();
															return (
																e.waitUntil(
																	saveToCache(sw_caches.images.name, t, n),
																),
																a
															);
														})
														.catch(respondWithOfflineImage)
												: save_data || slow_connection
													? respondWithFallbackImage(a)
													: fetch(t, fetch_config.images)
															.then((a) => {
																const n = a.clone();
																return (
																	e.waitUntil(
																		saveToCache(sw_caches.other.name, t, n),
																	),
																	a
																);
															})
															.catch(function () {
																return respondWithFallbackImage(
																	a,
																	offline_image,
																);
															})),
									),
								)
							: e.respondWith(
									caches.match(t).then(
										(n) =>
											n ||
											(save_data || slow_connection
												? new Response("", {
														status: 408,
														statusText:
															"This request was ignored to save data.",
													})
												: fetch(t)
														.then((n) => {
															const s = n.clone();
															return (
																isHighPriority(a)
																	? e.waitUntil(
																			saveToCache(sw_caches.static.name, t, s),
																		)
																	: e.waitUntil(
																			saveToCache(sw_caches.other.name, t, s),
																		),
																n
															);
														})
														.catch(respondWithOfflinePage)),
									),
								));
	}),
	self.addEventListener("install", function (e) {
		(self.skipWaiting(),
			e.waitUntil(
				caches.open(sw_caches.static.name).then(function (e) {
					return e.addAll(preinstall);
				}),
			));
	}));
